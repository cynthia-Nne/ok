$server = "<your-server>.database.windows.net"
$database = "<your-database>"
$user = "<your-username>"
$password = "<your-password>"

$connectionString = "Server=tcp:$server,1433;Initial Catalog=$database;Persist Security Info=False;User ID=$user;Password=$password;MultipleActiveResultSets=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"

try {
    Write-Host "Attempting to wake SQL database..."
    $conn = New-Object System.Data.SqlClient.SqlConnection
    $conn.ConnectionString = $connectionString
    $conn.Open()
    Write-Host "✅ SQL Server is awake."
    $conn.Close()
}
catch {
    Write-Warning "First attempt failed. Retrying in 30 seconds..."
    Start-Sleep -Seconds 30
    try {
        $conn.Open()
        Write-Host "✅ SQL Server woke up after retry."
        $conn.Close()
    }
    catch {
        Write-Error "❌ Could not wake up SQL Server."
    }
}




trigger: none  # Don't run on code push

schedules:
  - cron: "0 6 * * *"  # Every day at 6:00 AM UTC
    displayName: Wake SQL Daily
    branches:
      include:
        - main
    always: true

pool:
  vmImage: 'windows-latest'

steps:
- task: PowerShell@2
  inputs:
    targetType: 'filePath'
    filePath: 'WakeSql.ps1'



param(
    [string]$SqlServer,
    [string]$Database
)

try {
    $connectionString = "Server=tcp:$SqlServer,1433;Initial Catalog=$Database;Integrated Security=False;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"
    $connection = New-Object System.Data.SqlClient.SqlConnection($connectionString)
    $connection.Open()
    Write-Host "Successfully connected to SQL Server: $SqlServer, Database: $Database"
} catch {
    Write-Error "Error connecting to SQL Server: $SqlServer, Database: $Database"
    Write-Error $_.Exception.Message
} finally {
    if ($connection -ne $null -and $connection.State -eq "Open") {
        $connection.Close()
    }
}





trigger: none

schedules:
- cron: "0 6 * * *"
  displayName: Daily wake-up job
  branches:
    include:
    - main

pool:
  vmImage: 'windows-latest'

steps:
- task: PowerShell@2
  inputs:
    filePath: '$(Build.SourcesDirectory)/wake-up-script.ps1'
    arguments: '-SqlServer "$(SqlServer)" -Database "$(Database)"'






stages:
- stage: WakeUpDatabase
  displayName: 'Wake Up Database'
  jobs:
  - deployment: WakeUpDatabase
    displayName: 'Wake Up Database'
    pool:
      vmImage: 'windows-latest'
    environment: ${{ parameters.environment }}
    strategy:
      runOnce:
        deploy:
          steps:
          - task: PowerShell@2
            displayName: 'Execute Wake-Up Script'
            inputs:
              filePath: '$(powershellScriptsPath)/wake-up-script.ps1'
              arguments: '-SqlServer "$(sqlServer)" -Database "$(sqlDatabase)"'
trigger: none

schedules:
  - cron: "0 6 * * *"
    
displayName: Daily wake-up job

branches:
  include:
    - "Infrastructure\NDRDataMigration\"
    - "pipelines\NDR_Datamigration\"
always: true

pool: 'CISPWA - Dev'

parameters:
  - name: environment
    type: string
    default: "dev"
    
variables:
  resourceGroupName: $()
  sqlServerName: ''
  databaseName: ''
  sqlUsername: ''
  keyVaultName: 's'
  
stages:
  - stage: WakeUpDatabase
    displayName: "Wake Up Database"
    jobs:
      - job: WakeUpDatabase
        displayName: "Wake Up Database"
        pool:
          vmImage: "windows-latest"
        steps:
          # Step to fetch SQL password from Key Vault
          - task: AzureCLI@2
            displayName: 'Retrieve Secret from KeyVault'
            inputs:
              azureSubscription: 'BST Dev Connection-Cloud Platform'
              scriptType: 'ps'
              scriptLocation: 'inlineScript'
              inlineScript: |
                Write-Host "Fetching SQL secrets ... "
                $secret1 = az keyvault secret show --name '' --vault-name '$(keyVaultName)' --query value -o tsv
                if (!$secret1){
                  Write-Host "SQL secret fetch failed or returned null ... "
                } else {
                  Write-Host "SQL secret fetched, setting variable on pipeline"
                  Write-Host "##vso[task.setvariable variable=SQL-Admin-Pass-Var;isSecret=true]$secret1"
                }
          
          # Execute the PowerShell script with secrets from Key Vault
          - task: PowerShell@2
            displayName: "Execute Wake-Up Script"
            inputs:
              filePath: "$(System.DefaultWorkingDirectory)/"
              arguments: >
                -SqlServer "$(sqlServerName)" 
                -Database "$(databaseName)" 
                -User "$(sqlUsername)" 
                -Password "$(SQL-Admin-Pass-Var)"
              failOnStderr: false


param(
    [Parameter(Mandatory=$true)]
    [string]$SqlServer,
    
    [Parameter(Mandatory=$true)]
    [string]$Database,
    
    [Parameter(Mandatory=$true)]
    [string]$User,
    
    [Parameter(Mandatory=$true)]
    [string]$Password
)

try {
    $ConnectionString = "Server=tcp:$SqlServer,1433;Initial Catalog=$Database;User ID=$User;Password=$Password;Encrypt=True;TrustServerCertificate=False;Connection Timeout=30;"
    $Connection = New-Object System.Data.SqlClient.SqlConnection($ConnectionString)
    $Connection.Open()
    Write-Host "Successfully connected to SQL Server: $SqlServer, Database: $Database"
    
    # Add your database operations here
    
} catch {
    Write-Error "Error connecting to SQL Server: $SqlServer, Database: $Database"
    Write-Error $_.Exception.Message
} finally {
    if ($Connection -ne $null -and $Connection.State -eq "Open") {
        $Connection.Close()
    }
}











[Parameter(Mandatory=$true)]
[string]$SqlServer,

[Parameter(Mandatory=$true)]
[string]$Database,

[Parameter(Mandatory=$true)]
[string]$User,

[Parameter(Mandatory=$true)]
[string]$Password

# Define max retry attempts and delay between attempts
$maxRetries = 10
$retryDelay = 30  # seconds
$attempt = 1
$connected = $false

# First check if the SQL Server service is running
try {
    # Determine service name (default instance vs named instance)
    $instanceParts = $SqlServer.Split("\")
    $serverName = $instanceParts[0]
    $instanceName = if ($instanceParts.Length -gt 1) { $instanceParts[1] } else { $null }
    
    $serviceName = if ([string]::IsNullOrEmpty($instanceName)) { "MSSQLSERVER" } else { "MSSQL`$$instanceName" }
    
    # Check service status - may require admin rights
    $service = Get-Service -Name $serviceName -ComputerName $serverName -ErrorAction SilentlyContinue
    
    # If service exists but is not running, try to start it
    if ($service -and $service.Status -ne 'Running') {
        Write-Host "SQL Server service is not running. Attempting to start..."
        Start-Service -Name $serviceName -ComputerName $serverName
        Start-Sleep -Seconds 10  # Give it time to start
    }
    
    # Now try to connect with retry logic
    $ConnectionString = "Server=$SqlServer;Initial Catalog=$Database;User ID=$User;Password=$Password;Encrypt=True;TrustServerCertificate=true;Connection Timeout=30;"
    
    while (-not $connected -and $attempt -le $maxRetries) {
        Write-Host "Connection attempt $attempt of $maxRetries..."
        
        try {
            $Connection = New-Object System.Data.SqlClient.SqlConnection($ConnectionString)
            $Connection.Open()
            
            # Check if connection is actually responsive by running a simple query
            $query = "SELECT 1 AS IsAwake"
            $command = $Connection.CreateCommand()
            $command.CommandText = $query
            $command.CommandTimeout = 15  # Short timeout for the test query
            $result = $command.ExecuteScalar()
            
            Write-Host "Successfully connected to SQL Server: $SqlServer, Database: $Database"
            $connected = $true
            
            # Add your database operations here
            # For example, you might want to run additional "wake up" operations
            Write-Host "Database is now awake and responsive"
            
            # Close this connection before finishing
            $Connection.Close()
        }
        catch {
            Write-Host "Attempt $attempt failed: $_"
            
            # Clean up any partial connection
            if ($Connection -ne $null -and $Connection.State -eq 'Open') {
                $Connection.Close()
            }
            
            # If we haven't reached max retries, wait before trying again
            if ($attempt -lt $maxRetries) {
                Write-Host "Waiting $retryDelay seconds before next attempt..."
                Start-Sleep -Seconds $retryDelay
            }
            else {
                Write-Error "Failed to connect after $maxRetries attempts. Last error: $_"
            }
        }
        
        $attempt++
    }
}
catch {
    Write-Error "Error in SQL Server wake-up process: $_"
}
